<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><title>Synchronization</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script></head><body class=UnframedPage onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.35 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<table border=0 cellspacing=0 cellpadding=0 width=100%><tr><td class=MenuSection valign=top><!--START_ND_MENU--><div class=MEntry><div class=MFile><a href="junction_doc_about-txt.html">About TrimPath Junction</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run-txt.html">Runtime Environments</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_browser-txt.html">Runtime In The Browser</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_server-txt.html">Runtime On The Server</a></div></div><div class=MEntry><div class=MFile id=MSelected>Synchronization</div></div><div class=MEntry><div class=MFile><a href="junction_doc_translation-txt.html">Translations</a></div></div><div class=MEntry><div class=MFile><a href="junction-js.html">TrimPath.<span class=HB> </span>junction</a></div></div><div class=MEntry><div class=MFile><a href="junctionClient-js.html">TrimPath.<span class=HB> </span>junctionClient</a></div></div><div class=MEntry><div class=MFile><a href="junctionUtil-js.html">TrimPath.<span class=HB> </span>junctionUtil</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_controller-txt.html">web-MVC Controller</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_model-txt.html">web-MVC Model</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_view-txt.html">web-MVC View</a></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Index</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MIndex><a href="../index/General.html">Everything</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Variables.html">Variables</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Properties.html">Properties</a></div></div></div></div></div><!--END_ND_MENU--></td>

<td class=ContentSection valign=top><div class=CGeneric id=MainTopic><div class=CTopic><h1 class=CTitle><a name="Synchronization"></a>Synchronization</h1><div class=CBody><p class=CParagraph>The Junction synchronization system provides several basic services to propagate and handle...</p><ul class=CBulletList><li>Codebase updates</li><li>Database schema updates or migrations</li><li>Database record-level replication</li></ul><h4 class=CHeading>simpleSync</h4><p class=CParagraph>The protocol Junction implements is called &lsquo;simpleSync&rsquo;.&nbsp;  Its design is focused around a database-to-database level of synchronization, at the record level.&nbsp;  Other protocols, in contrast, might focus on recording and synchronizing higher-level command objects, or REST actions, or harmonizing file deltas, or reordering insert/delete commands, or some other concept, with different pros and cons to each kind of synchronization.</p><p class=CParagraph>Just as the saying goes with distributed objects, &lsquo;there is no location transparency&rsquo;, perhaps we can also say with distributed databases, &lsquo;there is no synchronization transparency&rsquo;.&nbsp;  Application developers need be aware of how simpleSync works, and how it can affect their designs, data models, and code.</p><h4 class=CHeading>Sync Request Initiation</h4><p class=CParagraph>A synchronization request is initiated by the client web-browser.&nbsp; This is due to the usage of the HTTP protocol, where a web-server cannot initiate requests.</p><p class=CParagraph>As part of the sync request, the Junction client transmits...</p><ul class=CBulletList><li>its current application version,</li><li>its unique client-side database id (or &lsquo;ident&rsquo;),</li><li>its last sync request timestamp</li><li>a delta of records that have changed in the client-side database since the last sync.</li></ul><h4 class=CHeading>Database Identity (or ident)</h4><p class=CParagraph>On the database ident, each database in the Junction world is assigned a unique numeric identifier, or &lsquo;ident&rsquo;.&nbsp;  For example, each server-side RDBMS in a team space for a particular application has a unique ident.&nbsp;  On the client-side, each Google Gears RDBMS database will be assigned a unique ident.&nbsp;  Each time a memory-database is created by the client-side Junction system, a unique ident is also assigned.</p><p class=CParagraph>Junction uses a current datetime plus random number to generate these unique database ident&rsquo;s.</p><h4 class=CHeading>Codebase Updates</h4><p class=CParagraph>In response to the sync request, the first thing the Junction server checks is that the client or requestor is running the latest or same version of application code that exists on the server.</p><p class=CParagraph>The Junction server uses the last-modified timestamp of the application code directory as the application&rsquo;s version number.&nbsp; Developers should be careful to update or &lsquo;touch&rsquo; the code directory&rsquo;s last-modified timestamp whenever the application&rsquo;s codebase changes, to force existing clients to receive new code updates.&nbsp;  Pernicious bugs might seem to appear if you forget to do a &lsquo;touch&rsquo;.</p><p class=CParagraph>If the client is running outdated code, the Junction server sends a response with a complete copy of the entire, latest application codebase.</p><p class=CParagraph>The client-side Junction system uses that entire, complete copy of the application codebase to &lsquo;wipe out&rsquo; its old codebase, replacing it with the new application codebase.&nbsp;  Even if you change only a single line of code in the application, this simple protocol always transmits the entire, complete application codebase to the client in response to a codebase update.</p><h4 class=CHeading>Database Schema Updates or Migrations</h4><p class=CParagraph>In the complete application codebase that the client receives, besides the web-MVC code, the client also receives database schema migration scripts.&nbsp;  These are the *.js files that live under the db/migrate directory.&nbsp;  The client-side Junction system executes these scripts, in sorted order, to ensure its local client-side RDBMS is updated to the same schema version as the server-side RDBMS.</p><p class=CParagraph>By convention, these scripts are named like 0001_initial.js, 0002_add_price_columns.js, NNNN_some_text_description.js, to facilitate sorting.</p><p class=CParagraph>At this point, the client-side Junction system should be running the same version of application code and database schema as the server, so the client-side Junction system tries to initiate another sync request.&nbsp;  That is, the client-side Junction system repeats the &lsquo;Sync Request Initiation&rsquo;.</p><h4 class=CHeading>Database Record-Level Replication</h4><p class=CParagraph>When the Junction server receives a sync request, it first checks that the client or requestor is running the correct version of application code and schema.&nbsp;  If the versions match what the server is running, the server proceeds in processing the delta of records that were sent by the client.</p><p class=CParagraph>The delta of records includes any table rows that were inserted, updated or deleted since the last the the client sync&rsquo;ed.</p><h4 class=CHeading>Tracking Columns</h4><p class=CParagraph>The Junction system uses special database tables and columns to help the client-side Junction system track which records were changed since the last sync request made by the client.&nbsp;  These special database columns are automatically created by the Junction system if you used the Junction API of createStandardTable() in your database migration scripts.&nbsp;  These special tracking columns include...</p><blockquote><pre class=CCode>- id          integer primary key autoincrement<br>- created_at  datetime<br>- updated_at  datetime<br>- active      integer<br>- version     integer<br>- id_start    integer<br>- id_start_db varchar(40)<br>- synced_at   datetime</pre></blockquote><p class=CParagraph>The created_at and updated_at columns are automatically filled and updated by the Junction system whenever you call the Model.newInstance() and save() method of a Model instance.</p><p class=CParagraph>The version number column is automatically incremented, also, whenever you call the save() method of a Model instance.</p><h4 class=CHeading>The id column</h4><p class=CParagraph>Records are assigned permanent, positive id numbers by the server-side RDBMS.&nbsp;  If the application code is executed on the Junction SSWAS (server-side web application server), getting a new positive id number from the server-side RDBMS is easy.</p><p class=CParagraph>On the client-side Junction system, however, when a record is first created, the Junction client system does directly not request a new positive id number from the server.&nbsp;  Instead, the client-side Junction system just immediately assigns a &lsquo;unique&rsquo; negative id number to the record, where the negative id number is unique to the local, client-side database only.&nbsp;  The client-side Junction system tracks a monotonically decreasing negative id number on a per-database manner, so it can do fast negative-number id assignment.</p><h4 class=CHeading>The id_start and id_start_db columns</h4><p class=CParagraph>When a new record is created and saved, the Junction system also fills in the id_start column with a copy of the record&rsquo;s id number.&nbsp; If created on the client-side, then, both id and id_start will be a negative number.&nbsp;  If created on the server-side, both id and id_start will be positive.</p><p class=CParagraph>Also, the Junction system fills in the id_start_db column with the local database ident.</p><p class=CParagraph>This information helps Junction track who created the record, and helps Junction map from negative id&rsquo;s to positive id&rsquo;s (when they&rsquo;re assigned later) and vice-versa, from postitive id&rsquo;s to negative.</p><p class=CParagraph>The id_start and id_start_db columns are only assigned during record creation.</p><h4 class=CHeading>Record Delta Tracking Via Model</h4><p class=CParagraph>When running on the client-side, Junction watches object-relational Model calls for when new Model instances are created and saved.&nbsp;  For example, when you call invoice.save(), Junction remembers that a record in the Invoice table was either inserted/created or updated.&nbsp;  That record is then a candidate for synchronization on the next sync protocol request.</p><p class=CParagraph>However, if you directly call INSERT, UPDATE, or DELETE via direct SQL statments against the database rather than going through the object-relational Model API, Junction will not detect that direct SQL-modified records have been changed.&nbsp;  Thus, such records will not be synchronized.&nbsp;  The key is for developers to always use Model API&rsquo;s to ensure proper synchronization tracking.</p><p class=CParagraph>Record delta tracking is not performed for the server-side Junction system, as the server-side RDBMS is considered the source of truth, and thus is never considered to be outdated.</p><h4 class=CHeading>The active column, the active pattern, and handling DELETE&rsquo;s</h4><p class=CParagraph>There is one scenario, however, where not tracking server-side record deltas is an issue, and that is with respect to record DELETE&rsquo;s.&nbsp; Once a record is DELETE&rsquo;d from an RDBMS, it&rsquo;s gone and won&rsquo;t appear in any query results.</p><p class=CParagraph>In the scenario where we DELETE a record from the server-side RDBMS, and at a later time a client requests a synchronization, the server could mistakenly <b>not</b> inform the client that a record was DELETE&rsquo;d, because DELETE&rsquo;d records do not appear in any query results anymore.</p><p class=CParagraph>To solve this scenario, Junction recommends using the active flag column, and deactivating records instead of physically DELETE&rsquo;ing them.&nbsp;  Deactivating a record is just setting its active column value to 0.&nbsp;  An active record has an active column value of 1.&nbsp; Junction provides Model API&rsquo;s such as deactivate() and findActive() to help developers code to the active flag column pattern.</p><p class=CParagraph>Instead of calling Invoice.find(...), developers should prefer calling Invoice.findActive(...), with the same parameters.&nbsp; The findActive() method adds the additional WHERE query clause of &lsquo; AND active = 1&rsquo; to any query it executes.</p><p class=CParagraph>Instead of calling invoice.destroy(), which performs a physical SQL DELETE, the developer should call invoice.deactivate(), which merely sets the active column value to 0 on the invoice record and save()&rsquo;s the invoice record.&nbsp;  During the save() call, the updated_at column and version colunn of the record are automatically updated, per normal Junction Model behavior.&nbsp;  To the synchronization system, thus, setting the active column value to 0 is just another record update that needs to be synchronized, and is handled through normal replication steps as described on this page.</p><p class=CParagraph>At a later time, after enough time has passed for the deactivation (setting active to 0) of a record has replicated to the server-side RDBMS and to all client RDBMS, then the record can be physically DELETE&rsquo;d or purged.&nbsp;  For example, just DELETE all records whose active = 0 and udpated_at is very long ago, according to application needs.</p><p class=CParagraph>Using the deactivation pattern, too, instead of true DELETE&rsquo;s, has the potential benefit of making support for undo features easier to implement.</p><h4 class=CHeading>Synchronized Tables Conventions</h4><p class=CParagraph>To be a candiated for synchronization, a table must follow some naming and design conventions.&nbsp;  The table must not have the suffix of &lsquo;Local&rsquo;.&nbsp;  For example, PreferenceLocal or ScratchTempLocal are two tables which will not be synchronized or replicated by Junction.</p><p class=CParagraph>Also, a table must have the tracking columns as described previously.</p><h4 class=CHeading>The db/sync.json file</h4><p class=CParagraph>By default, Junction synchronizes all records in all tables.&nbsp; While this is a useful default for faster initial development and prototyping of simple applications, Junction also provides a way to override this naive policy via the optional code/db/sync.json file.&nbsp;  Each application has its own code/db/sync.json file, and hence, ther own potential synchronization policy.</p><p class=CParagraph>The file format for the code/db/sync.json file is JSON.&nbsp; For example:</p><blockquote><pre class=CCode>{<br>  clientDbCache: {<br>    general : {<br>      Action  : &quot;WHERE (active = 1 AND completed_at IS NULL) OR (updated_at &gt;= date('now', '-1 month'))&quot;,<br>      Context : true,<br>      Project : true<br>    }<br>  }<br>}</pre></blockquote><p class=CParagraph>In it, an application developer can specify a subset of each server-side database table that will be cached by client web-browsers.&nbsp;  This is done by specifying a WHERE clause string per table, or the value of true to specify that the entire table should be cached on the client.</p><p class=CParagraph>Above, both the Context and Project tables will be cached in their entirety in the client-side RDBMS.</p><p class=CParagraph>And, the Active table will have only those records cached in the client-side that are currently active and not yet been completed, OR who have been updated within the last month.</p><p class=CParagraph>As part generating the synchronization response, Junction uses the above code/db/sync.json file information to run queries against the server-side RDBMS, to construct which records need to be sent to the client as part of the synchronization reply.</p><h4 class=CHeading>The synced_at column</h4><p class=CParagraph>The synced_at column holds the server timestamp of when the server-side Junction system processed the record during sync message handling.</p><p class=CParagraph>The synced_at timestamp for a record might be more recent than the updated_at column value of that record.&nbsp;  This might happen, for instance, when a record is changed by an offline client.&nbsp; So, the record&rsquo;s updated_at column is changed to time T.&nbsp; Later, the record is transmitted as part of a delta of records in a sync request to the server.&nbsp;  The Junction server updates the server-side RDBMS with the record delta, and updates the synced_at column of the record.&nbsp;  At this point, in the server-side RDBMS, the updated_at value is still T, but the synced_at value is T+1 for the record.&nbsp;  Furthermore, the Junction system might include the record as part of the sync response message to any client.&nbsp;  As a client receives and processes the response message, it updates its local client-side RDBMS with the record information, which has updated_at value of T and synced_at value of T+1.</p><p class=CParagraph>The client-side Junction system also remembers its last time of sending a sync request message, for use when it sends its next sync request message in the future.</p><p class=CParagraph>The synced_at column is queried by the Junction synchronization system to limit the response it will send to clients.&nbsp;  That is, Junction appends an SQL WHERE AND clause of synced_at &gt;= [last sync request timestamp] to the query it uses to construct which reply records will be sent to the client.</p><h4 class=CHeading>Assumptions / Notes</h4><p class=CParagraph>The Junction simpleSync protocol makes several assumptions for it to work correctly...</p><ul class=CBulletList><li>friendly, cooperative clients and servers (no liars)</li><li>synchronized clocks, or correct (enough) clock time on computers</li><li>db identity (ident) uniqueness</li><li>monotonically decreasing negative temporary id numbers are unique per db ident</li></ul><h4 class=CHeading>Application Design Rules</h4><p class=CParagraph>With simpleSync, the key design points or rules of thumb to successful usage are...</p><ul class=CBulletList><li>Always insert - said another way, never update -- create new records only.</li><li>Also, don&rsquo;t delete - instead, deactivate records, and purge them much later.</li></ul><p class=CParagraph>As rules of thumb, these guidelines are just that.&nbsp;  Sometimes you need to color outside the lines.</p><p class=CParagraph>However, consider the case of a wiki application.&nbsp;  Edits to wiki pages might be tracked in a version/history table.&nbsp;  That version/history table can be considered an &lsquo;insert only&rsquo; or &lsquo;append only&rsquo; table.&nbsp;  Some wiki database designs have only the version/history table.</p><p class=CParagraph>Conflict resolution on such insert/append only tables can be relatively easy to think about, as all changes across history are available for the resolution decision.</p><p class=CParagraph>Or, consider an sales order tracking application.&nbsp;  One design might include an Order table with a status column, where the status value changes during the Order lifecycle through values of &lsquo;open&rsquo;, &lsquo;complete&rsquo;, &lsquo;shipped&rsquo;, &lsquo;received&rsquo;, &lsquo;cancelled&rsquo;, and &lsquo;returned&rsquo;.&nbsp; Such an Order table requires UPDATE&rsquo;s to the status column.</p><p class=CParagraph>An alternative, insert-only or append-only design calls for adding an additional OrderStatus table, which has a foreign-key relationship to a parent order_id.&nbsp;  (OrderStatus belongs_to Order.)&nbsp; The OrderStatus table is an insert-only/append-only table.&nbsp;  Each change in to an Order&rsquo;s state merits inserting a new record in the OrderStatus table, which allows tracking of detailed OrderStatus change timestamps (created_at/updated_at) and extra columns such as notes fields.</p><p class=CParagraph>Moreover, if you added a previous_order_status_id column to the OrderStatus table, conflict detection becomes simplier.&nbsp; After awhile, imagine that all synchronization/replication/merging of records across database eventually settles down.&nbsp; Then, a simple query which returns more than one OrderStatus record with the same previous_order_status_id shows you that a conflict happened.</p><p class=CParagraph>Perhaps two different offline users concurrently changed the Order&rsquo;s state.&nbsp; Application-specific code, at this point, might help automatically determine the resolution.&nbsp;  E.g, if one user &lsquo;complete&rsquo;ed the order while a different user &lsquo;cancel&rsquo;led the order, the cancellation might automatically win as the correct state.</p><p class=CParagraph>In the worst case, if user involvement is needed for conflict resolution, displaying the full history and action trail to users is useful, and possible with the history-intensive insert-only/append-only kind of design.&nbsp;  E.g, hey, we both sold the last remaining prebuilt 16TB disk array to two different customers.&nbsp;  Congrats.&nbsp; But, which customer will we inform that will have to wait a little longer?</p></div></div></div>

</td>

</tr></table><div class=Footer><!--START_ND_FOOTER-->Generated by <a href="http://www.naturaldocs.org">Natural Docs</a><!--END_ND_FOOTER--></div>
<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>