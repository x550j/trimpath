<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><title>Runtime In The Browser</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script></head><body class=UnframedPage onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.35 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<table border=0 cellspacing=0 cellpadding=0 width=100%><tr><td class=MenuSection valign=top><!--START_ND_MENU--><div class=MEntry><div class=MFile><a href="junction_doc_about-txt.html">About TrimPath Junction</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_run-txt.html">Runtime Environments</a></div></div><div class=MEntry><div class=MFile id=MSelected>Runtime In The Browser</div></div><div class=MEntry><div class=MFile><a href="junction_doc_run_server-txt.html">Runtime On The Server</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_sync-txt.html">Synchronization</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_translation-txt.html">Translations</a></div></div><div class=MEntry><div class=MFile><a href="junction-js.html">TrimPath.<span class=HB> </span>junction</a></div></div><div class=MEntry><div class=MFile><a href="junctionClient-js.html">TrimPath.<span class=HB> </span>junctionClient</a></div></div><div class=MEntry><div class=MFile><a href="junctionUtil-js.html">TrimPath.<span class=HB> </span>junctionUtil</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_controller-txt.html">web-MVC Controller</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_model-txt.html">web-MVC Model</a></div></div><div class=MEntry><div class=MFile><a href="junction_doc_view-txt.html">web-MVC View</a></div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Index</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MIndex><a href="../index/General.html">Everything</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Variables.html">Variables</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Properties.html">Properties</a></div></div></div></div></div><!--END_ND_MENU--></td>

<td class=ContentSection valign=top><div class=CGeneric id=MainTopic><div class=CTopic><h1 class=CTitle><a name="Runtime_In_The_Browser"></a>Runtime In The Browser</h1><div class=CBody><p class=CParagraph>How does the Junction runtime actually work in the browser?</p><p class=CParagraph>The analogy described in the <a href="junction_doc_run-txt.html#Runtime_Environments" class=LGeneric id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Runtime Environments</a> page was to imagine that there is a miniature web-application-server running in your web browser.&nbsp;  At root, such a thing is implemented entirely as just plain old JavaScript hosted inside a web page that loads and runs your application&rsquo;s web-Model-View-Controller (web-MVC) code.&nbsp; This miniature, client-side web-application-server is comprised of and manages several different kinds of JavaScript code...</p><ul class=CBulletList><li>Junction utility code (junctionUtil.js)</li><li>Junction system code (junction.js and junctionClient.js)</li><li>Application &lsquo;server-side&rsquo; code, or web-MVC code.</li><li>Application &lsquo;client-side&rsquo; code, such as DOM event handlers.</li></ul><p class=CParagraph>In the following discussion, we sometimes use acronyms to distingish between a &lsquo;real&rsquo; or traditional-style, server-side web-application server (SSWAS), and the &lsquo;miniature&rsquo;, in-browser, client-side web-application server (CSWAS).</p><h4 class=CHeading>Junction utility code</h4><p class=CParagraph>The low-level utility code for Junction, found in trimpath/junctionUtil.js, is designed to run in both SSWAS and CSWAS environments.&nbsp;  That is, it never accesses environment specific objects or resources such as the DOM document, DOM window or the filesystem.</p><h4 class=CHeading>Junction system code</h4><p class=CParagraph>The heart of Junction system is found in trimpath/junction.js.&nbsp;  The junction.js code is is designed to also run in both SSWAS and CSWAS environments.&nbsp;  The junction.js code requires an environment-specific &lsquo;plug-in&rsquo; to be registered.&nbsp;  This plug-in, also called &lsquo;env&rsquo; (short for &lsquo;environment&rsquo;), provides abstract services that the Junction system requires (such as file loading), but which have different implementations for SSWAS and CSWAS environments.&nbsp;  The CSWAS env implementation is found in trimpath/junctionClient.js.</p><p class=CParagraph>As an example, a file loading service implemented for the SSWAS environment would access a real operating-system filesystem, opening-reading-and-closing real File objects.&nbsp;  For the CSWAS environment, a file loading service would be implemented by instead simply retrieving text bodies from DOM elements (e.g.,  document.getElementById(filePath).innerHTML).&nbsp;  Because the CSWAS environment can only support text-based content, the env or environment plug-in API is constrained and designed to support only something like a textRead(filePath) function.</p><p class=CParagraph>Together, the junction.js code hooked up with junctionClient.js code provide the so-called miniature web-application-server that runs completely hosted within a web-browser.</p><h4 class=CHeading>Application &lsquo;server-side&rsquo; code, or web-MVC code</h4><p class=CParagraph>Tranditionally, developers have considered a web-Model-View-Controller codebase to be server-side or server-executed code.&nbsp;  That is, controller dispatching, model CRUD (create, retreive, update and delete), and template parsing and rendering are usually executed on a remote web-application server.&nbsp; This situation is similar to server-side web-MVC frameworks such as Ruby on Rails, Django, and Java Servlet/JSP/Hibernate.</p><p class=CParagraph>Junction allows web-MVC code to also execute in a web-application server that lives and runs within a web-browser client.&nbsp;  However, <u>web-MVC application code is still to be considered server code</u>, no matter that it is hosted and executed within a &lsquo;server&rsquo; that&rsquo;s been migrated to the client.</p><p class=CParagraph>Because we still consider web-MVC code to be server-side code, the web-MVC code should still be constrained as to what objects it can access.&nbsp;  For example, even though an application&rsquo;s web-MVC code might be actually running on the client web-browser hosted within a HTML page (in a CSWAS), the web-MVC code <u>must not</u> access the client browser&rsquo;s DOM objects such as document or window or alert(), even though these DOM objects are, strictly speaking, actually there.&nbsp;  Following such rules allows a single web-MVC application codebase to be executed on either a SSWAS or a CSWAS environment.</p><p class=CParagraph>The reverse rule applies, too.&nbsp;  For example, although a web-MVC application might be actually running in a server-side web-application server (SSWAS), it must not attempt to directly access any server-only resources (like the server&rsquo;s filesystem) if you want to allow that same codebase to also run in a CSWAS.&nbsp;  (The exception, though, is when you choose to add conditional IF-THEN-ELSE checking into your application code.)</p><h4 class=CHeading>Application &lsquo;client-side&rsquo; code, such as DOM event handlers</h4><p class=CParagraph>The &lsquo;client-side&rsquo; code is the code that only runs in a client.&nbsp; For example, this is the script that usually goes into onclick/onsubmit/onmousemove and other DOM event handlers.&nbsp; And, this is the code and helper functions that are invoked by your DOM event handlers.</p><p class=CParagraph>The jQuery/Prototype/Dojo code that you used to hook up or bind up those DOM event handlers and provide fancy animations are also considered client-side only code.</p><p class=CParagraph>Keeping the distinction between client-side code and server-side web-MVC code clear, especially when both types of code are written in the same language of JavaScript, is sometimes challenging.&nbsp; For example, consider...</p><blockquote><pre class=CCode>&lt;div&gt;<br>&lt;script&gt;var x = 1 + 2;&lt;/script&gt;<br>&lt;a onclick=&quot;alert(x)&quot;&gt;press me&lt;/a&gt;<br>&lt;/div&gt;</pre></blockquote><blockquote><pre class=CCode>&lt;div&gt;<br>&lt;% var x = 1 + 2; %&gt;<br>&lt;a onclick=&quot;alert(x)&quot;&gt;press me&lt;/a&gt; // WHOOPS, wrong.  The x is undefined.<br>&lt;/div&gt;</pre></blockquote><p class=CParagraph>In contrast, with a framework such as Django or Ruby on Rails, the language shift between Python/Ruby and JavaScript seems to help enforce the distinction between server-side code and client-side code.&nbsp; The distinction between different types or &lsquo;sides&rsquo; of code, albeit all in a single programming language of JavaScript, then, is something that developers will have to be explicitly aware of until it becomes natural for them.</p><h4 class=CHeading>Runtime code separation</h4><p class=CParagraph>To help enforce a separation of server-side web-MVC code and client-side DOM-event-handler code (even though both are executed in the same web browser), Junction provides a runtime separation of scopes.</p><p class=CParagraph>Junction implements this separation by running server-side web-MVC code in the primary downloaded web page document/window.&nbsp;  And, Junction uses a dynamically created and displayed child IFRAME to execute all client-side code.&nbsp;  By using this scheme, any global variables or objects created by the server-side web-MVC code are not implicitly or mistakenly accessible by the client-side DOM-event-handler code, and vice versa.&nbsp;  (NOTE: although your could try to explicitly traverse through the DOM IFRAME parent-child API&rsquo;s to tweak objects &lsquo;on the other side&rsquo; of the IFRAME, such code would not run correctly in a SSWAS environment).</p><p class=CParagraph>Another benefit of the IFRAME-based approach is that it provides the application developer with complete, fine-grained control of the whole HTML page.&nbsp;  That is, the application&rsquo;s web-MVC code is allowed (and expected) to generate a full HTML response page.&nbsp; Everything from the opening &lt;html&gt; tag to close &lt;/html&gt; tag is under the application&rsquo;s control.&nbsp;  This also allows Junction to be technology library and technique agnostic -- feel free to use your favorite DHTML techniques and tech libraries (like Prototype/Dojo/jQuery/etc) or add-ons such as Flash, Java applets, etc.&nbsp;  Junction does not put any abstractions in the way (such as an XML-based GUI markup language) of letting you have deep, down-to-the-metal control.</p><p class=CParagraph>Let&rsquo;s follow a request: Junction invokes an action method on your Controller code, which in turn usually invokes CRUD operations on Model object-relational objects.&nbsp;  Eventually, a template is parsed and rendered and a dynamically generated HTML web page is the result.&nbsp; The Junction CSWAS system now takes that dynamically generated HTML web page and writes it out as the content of the managed child IFRAME.&nbsp; This child IFRAME is defined to automatically take up the entire client area of its browser window.&nbsp;  The effect is the dynamically generated web page looks just as if it had been delivered as a response from a remote SSWAS system.</p><p class=CParagraph>Now, the web-browser, following normal procedure, will invoke whatever &lsquo;client-side&rsquo; &lt;SCRIPT&gt;&rsquo;s that were defined.&nbsp;  (Aside: actually, Junction tries to provide a little help here, to ensure that &lt;SCRIPT&gt;&rsquo;s are evaluated correctly in the child IFRAME.)&nbsp;  If you had included jQuery/Prototype/Dojo or your other favorite JavaScripts, they would also be evaluated.</p><p class=CParagraph>Continuing, as the user provides input via mouse/pointer gestures and keyboard input, any DOM event-handlers and callback code that you had defined or hooked up would be invoked.&nbsp;  Since all this client-side code and script is contained and hosted inside a child IFRAME, this client-side code does not have implicit, shared access to the web-MVC code and objects hosted in the parent document/window.&nbsp; In short, this scheme imitates the same situation of a traditional client-side script not having implicit, shared access to the web-MVC objects that live in a true, remote SSWAS.&nbsp;  For example, a global variable defined by &lsquo;server-side&rsquo; web-MVC code does not interfere with a global variable defined by client-side &lt;SCRIPT&gt; or event-handler code.</p><h4 class=CHeading>TrimPath.junctionClient</h4><p class=CParagraph>Eventually, as the user is clicking around her web browser screen, he or she will eventually need to see new results from the database.&nbsp; That is, we will need to send a request into the CSWAS system to start a new web-MVC request-processing, template rendering cycle.</p><p class=CParagraph>For example, here is a link that the user might click on...</p><blockquote><pre class=CCode>&lt;a href=&quot;?controllerName=product&amp;actionName=list&quot;<br>   onclick=&quot;return TrimPath.junctionClient.get('product', 'list')&quot;&gt;<br>   List All Products<br>&lt;/a&gt;</pre></blockquote><p class=CParagraph>This pattern of link is actually designed to leverage the default behavior of web browsers and careful overriding that behavior.&nbsp; Junction provides helper methods to make it easy to generate these kinds of links (and also FORM&rsquo;s) from your templates (for example, see function linkToLocal()).</p><p class=CParagraph>During a click, the onclick handler invokes TrimPath.junctionClient.get(...).&nbsp; The TrimPath.junctionClient object provides methods like get() and post() which help to dispatch HTTP-like requests from the child IFRAME scope into the parent-window CSWAS request-processing system.&nbsp;  In short, TrimPath.junctionClient.get() and TrimPath.junctionClient.post() imitate the HTTP GET and HTTP POST requests, but just send them to the local, client-side web-application server for processing.&nbsp; When the CSWAS returns a normal response, the contents of the child IFRAME are overwritten with that response.&nbsp;  The end user, then, sees a new page of information.</p><p class=CParagraph>Alternatively, if the application was running in a server-side web-application server (SSWAS) environment, the system would not be using IFRAME&rsquo;s, because separation of server-side web-MVC code and client-side DOM event-handler code occurs naturally across remote processes.&nbsp;  Also, Junction would instead automatically provide a no-op implementation of TrimPath.junctionClient methods, which client-side event-handler code might still invoke.&nbsp;  In this situation, methods like TrimPath.junctionClient.get() and TrimPath.junctionClient.post() would instead do nothing and return a boolean value of true.&nbsp;  When invoked from an event handler, such as the onclick handler of a link as seen above, the true boolean return value signals to the web-browser to continue processing the link click event as normal.</p><p class=CParagraph>So, following the above example, the browser would then transmit a real HTTP request to a relative server URL resource, but with a changed URL query string parameter suffix of &lsquo;?controllerName=product&amp;actionName=list&rsquo;.&nbsp; The remote SSWAS would process that HTTP request and dispatch to the correct server-side web-MVC code, eventually replying with a full, dynamically-generated web result page that the client web browser would then display to the user.&nbsp;  This outcome is the same as for the CSWAS scenario (except without the child IFRAME container and perhaps performing visibly slower due to the network hops).</p></div></div></div>

</td>

</tr></table><div class=Footer><!--START_ND_FOOTER-->Generated by <a href="http://www.naturaldocs.org">Natural Docs</a><!--END_ND_FOOTER--></div>
<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CGeneric>You have several different options for deploying a Junction-based web application, depending on where you want your web application code and database to run...</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>